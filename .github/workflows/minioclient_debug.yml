name: Minioclient Debug Build (Windows â€“ resilient toolchain)

# ----------------------------------------------------------------------
# Manual trigger â€“ useful while we are debugging.
# ----------------------------------------------------------------------
on:
  workflow_dispatch: {}

# ----------------------------------------------------------------------
# Use PowerShell for every step on Windows.
# ----------------------------------------------------------------------
defaults:
  run:
    shell: pwsh

jobs:
  # ==============================================================
  # 1ï¸âƒ£ Checkout â€“ get both the repo youâ€™re testing and the minioclient source
  # ==============================================================
  checkout:
    name: Checkout repositories
    runs-on: windows-latest
    outputs:
      temp-dir: ${{ steps.temp-dir.outputs.path }}
    steps:
      - name: Checkout this repository
        uses: actions/checkout@v4

      - name: Checkout minioclient source (reference only)
        uses: actions/checkout@v4
        with:
          repository: cboettig/minioclient
          path: minioclient-src
          fetch-depth: 1

      - name: Create a shared temporary directory
        id: temp-dir
        run: |
          $tmp = Join-Path $env:TEMP ("minioclient_debug_" + [guid]::NewGuid())
          New-Item -ItemType Directory -Path $tmp | Out-Null
          echo "path=$tmp" >> $env:GITHUB_OUTPUT

  # ==============================================================
  # 2ï¸âƒ£ Install systemâ€‘level dependencies (OpenSSL, pkgâ€‘config, CMake, compiler)
  # ==============================================================
  install-system-deps:
    name: Install native libraries & compiler
    needs: checkout
    runs-on: windows-latest
    env:
      TEMP_DIR: ${{ needs.checkout.outputs.temp-dir }}
    steps:
      # ------------------------------------------------------------------
      # 2ï¸âƒ£1ï¸âƒ£ Bootstrap Chocolatey (if the runner somehow lacks it)
      # ------------------------------------------------------------------
      - name: Install Chocolatey (bootstrap if missing)
        run: |
          Set-ExecutionPolicy Bypass -Scope Process -Force
          if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
            iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
          }
        shell: pwsh

      # ------------------------------------------------------------------
      # 2ï¸âƒ£2ï¸âƒ£ Install the native packages we know weâ€™ll need
      # ------------------------------------------------------------------
      - name: Install native packages (OpenSSL, pkgâ€‘config, CMake, MinGW, VS Build Tools)
        run: |
          choco install -y openssl.light
          choco install -y pkgconfiglite
          choco install -y cmake
          choco install -y mingw
          choco install -y visualstudio2022buildtools `
            --package-parameters "--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended --passive --norestart"
        shell: pwsh

      # ------------------------------------------------------------------
      # 3ï¸âƒ£ Add MinGW to PATH (if it exists)
      # ------------------------------------------------------------------
      - name: Add MinGW bin to PATH (if present)
        run: |
          $mingwBin = "C:\ProgramData\chocolatey\lib\mingw\tools\install\mingw64\bin"
          if (Test-Path $mingwBin) {
            Write-Host "âœ… Adding MinGW ($mingwBin) to PATH"
            echo $mingwBin >> $env:GITHUB_PATH
          } else {
            Write-Warning "âš ï¸ MinGW bin folder not found â€“ will try VS Build Tools next."
          }
        shell: pwsh

      # ------------------------------------------------------------------
      # 4ï¸âƒ£ If MinGW wasnâ€™t added, locate VS Build Tools and initialise MSVC
      # ------------------------------------------------------------------
      - name: Locate VS Build Tools, initialise MSVC, and add to PATH
        run: |
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) {
            Write-Error "âŒ vswhere.exe not found â€“ cannot locate VS Build Tools"
            exit 1
          }

          $vsInstall = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (-not $vsInstall) {
            Write-Warning "âš ï¸ No VS Build Tools with VC component detected â€“ skipping VS path setup."
            exit 0
          }

          Write-Host "âœ… VS Build Tools found at $vsInstall"

          $msvcRoot = Join-Path $vsInstall "VC\Tools\MSVC"
          if (-not (Test-Path $msvcRoot)) {
            Write-Warning "âš ï¸ $msvcRoot does not exist yet â€“ forcing a firstâ€‘time init."
            $vcvars = Join-Path $vsInstall "Common7\Tools\VsDevCmd.bat"
            if (Test-Path $vcvars) {
              cmd /c "`"$vcvars`" && echo Init done"
            } else {
              Write-Error "âŒ Could not find VsDevCmd.bat â€“ cannot initialise MSVC."
            }
            Start-Sleep -Seconds 5
          }

          $msvcVersion = Get-ChildItem $msvcRoot -Directory |
                         Sort-Object Name -Descending |
                         Select-Object -First 1
          if (-not $msvcVersion) {
            Write-Error "âŒ No MSVC version folder found under $msvcRoot"
            exit 1
          }

          $vcBin = Join-Path $msvcVersion.FullName "bin\Hostx64\x64"
          if (Test-Path $vcBin) {
            Write-Host "âœ… Adding VS C++ bin ($vcBin) to PATH"
            echo $vcBin >> $env:GITHUB_PATH
          } else {
            Write-Error "âŒ Expected VC bin folder not found: $vcBin"
          }
        shell: pwsh

      # ------------------------------------------------------------------
      # 5ï¸âƒ£ Verify that a compiler is now reachable
      # ------------------------------------------------------------------
      - name: Verify compiler availability
        run: |
          Write-Host "`n=== Compiler version checks ==="
          if (Get-Command gcc -ErrorAction SilentlyContinue) {
            gcc --version
          } elseif (Get-Command cl -ErrorAction SilentlyContinue) {
            cl
          } else {
            Write-Error "âŒ No C/C++ compiler found in PATH after the setup steps."
          }

          Write-Host "`n=== pkg-config check ==="
          pkg-config --version || Write-Warning "pkg-config not found"

          Write-Host "`n=== OpenSSL version ==="
          openssl version || Write-Warning "OpenSSL not found"
        shell: pwsh

      # ------------------------------------------------------------------
      # 6ï¸âƒ£ Export PKG_CONFIG_PATH so OpenSSLâ€™s .pc file is visible
      # ------------------------------------------------------------------
      - name: Set PKG_CONFIG_PATH for OpenSSL
        run: |
          $opensslPc = "C:\ProgramData\chocolatey\lib\openssl.light\tools\openssl\share\pkgconfig"
          if (Test-Path $opensslPc) {
            $env:PKG_CONFIG_PATH = "$opensslPc;$env:PKG_CONFIG_PATH"
            Write-Host "âœ… PKG_CONFIG_PATH set to $opensslPc"
          } else {
            Write-Warning "âš ï¸ OpenSSL pkgâ€‘config directory not found â€“ some packages may not locate OpenSSL."
          }
        shell: pwsh

  # ==============================================================
  # 3ï¸âƒ£ OSâ€‘level diagnostics (helps spot missing headers, wrong arch, etc.)
  # ==============================================================
  diagnostics-os:
    name: Gather OS & compiler diagnostics
    needs: [checkout, install-system-deps]
    runs-on: windows-latest
    env:
      TEMP_DIR: ${{ needs.checkout.outputs.temp-dir }}
    steps:
      - name: System information (shortened)
        run: |
          systeminfo | Select-Object -First 20
        shell: pwsh

      - name: Important environment variables
        run: |
          Get-ChildItem Env: | Where-Object {
            $_.Name -match '^(PATH|INCLUDE|LIB|PKG_CONFIG_PATH|OPENSSL_ROOT_DIR|VSINSTALLDIR)$'
          } | Format-Table -AutoSize
        shell: pwsh

      - name: List files under the temporary directory (debug aid)
        run: |
          Get-ChildItem -Recurse -Force $env:TEMP | Out-String
        shell: pwsh

  # ==============================================================
  # 4ï¸âƒ£ Install R and the `remotes` helper package
  # ==============================================================
  setup-r:
    name: Install R (v4.4) and remotes
    needs: checkout
    runs-on: windows-latest
    env:
      TEMP_DIR: ${{ needs.checkout.outputs.temp-dir }}
    steps:
      - name: Install R (official binary from râ€‘lib)
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.4'
          use-public-rspm: true

      - name: Install R package `remotes`
        run: |
          install.packages('remotes', repos='https://cloud.r-project.org')
        shell: Rscript {0}

      - name: Record R version & library path (for debugging)
        run: |
          Rscript -e "cat('R version:', getRversion(), '\n')"
          Rscript -e "cat('R lib dir:', .libPaths()[1], '\n')"
        shell: pwsh

  # ==============================================================
  # 5ï¸âƒ£ Attempt to install minioclient â€“ capture **all** output
  # ==============================================================
  install-minioclient:
    name: Install minioclient (full log)
    needs: [checkout, setup-r, install-system-deps, diagnostics-os]
    runs-on: windows-latest
    env:
      TEMP_DIR: ${{ needs.checkout.outputs.temp-dir }}
    steps:
      - name: Checkout this repository (again â€“ needed for R session)
        uses: actions/checkout@v4
  
      - name: Install R (v4.4) â€“ same version as earlier
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.4'
          use-public-rspm: true
  
      - name: Install R package `remotes`
        run: |
          install.packages('remotes', repos='https://cloud.r-project.org')
        shell: Rscript {0}
  
      - name: Create R script that installs minioclient and prints env
        run: |
          $rScript = @"
          # ------------------------------------------------------------
          # Print the R environment (helps debugging)
          # ------------------------------------------------------------
          cat('--- ENV BEFORE INSTALL ---\n')
          print(Sys.getenv())
          cat('\n--- START minioclient install ---\n')
          
          remotes::install_github(
            repo = 'cboettig/minioclient',
            ref  = 'main',
            upgrade = 'never',
            dependencies = FALSE,
            quiet = FALSE
          )
          
          cat('\n--- END minioclient install ---\n')
          "@
  
          $scriptPath = Join-Path $env:TEMP 'install_minioclient.R'
          Set-Content -Path $scriptPath -Value $rScript -Encoding UTF8
          Write-Host "âœ… R script written to $scriptPath"
          echo "R_SCRIPT=$scriptPath" >> $env:GITHUB_ENV
        shell: pwsh

      # --------------------------------------------------------------
      # 5ï¸âƒ£5ï¸âƒ£ Execute the R script and capture **all** output (stdout+stderr)
      # --------------------------------------------------------------
      - name: Run the R script and capture everything
        id: install_step                     # give the step an ID
        env:
          MINIOTMP: ${{ needs.checkout.outputs.temp-dir }}
        run: |
          if (-not (Test-Path $env:MINIOTMP)) {
            New-Item -ItemType Directory -Path $env:MINIOTMP | Out-Null
          }
      
          $logFile = Join-Path $env:MINIOTMP 'minioclient_install.log'
      
          # Run Rscript and capture its exit status
          Rscript $env:R_SCRIPT *> $logFile
          $rc = $LASTEXITCODE
      
          Write-Host "âœ… Installation finished â€“ log saved to $logFile"
          Write-Host "ðŸ”Ž Rscript exit code: $rc"
      
          # Export the exit code so later steps can read it
          echo "install_rc=$rc" >> $GITHUB_OUTPUT
        shell: pwsh
        # **Do NOT** add continue-on-error here â€“ we want the real exit code preserved

      - name: Diagnose GitHub API connectivity
        run: |
          Write-Host "=== DNS lookup ==="
          nslookup api.github.com
      
          Write-Host "`n=== Simple curl ==="
          curl -s -w "\nHTTP status: %{http_code}\n" https://api.github.com/repos/cboettig/minioclient/contents/DESCRIPTION?ref=main
      
          Write-Host "`n=== PowerShell Invoke-WebRequest ==="
          try {
            $resp = Invoke-WebRequest -Uri "https://api.github.com/repos/cboettig/minioclient/contents/DESCRIPTION?ref=main" -UseBasicParsing -Headers @{ "User-Agent" = "github-actions" }
            Write-Host "Status: $($resp.StatusCode)"
          } catch {
            Write-Error "Invoke-WebRequest failed: $_"
          }
        shell: pwsh

      
      - name: Upload install log as artifact
        if: always()                         # <-- this line guarantees execution
        uses: actions/upload-artifact@v4
        with:
          name: minioclient-debug-logs
          path: |
            ${{ needs.checkout.outputs.temp-dir }}\minioclient_install.log
            ${{ needs.checkout.outputs.temp-dir }}/*.log

  # ==============================================================
  # 6ï¸âƒ£ Optional cleanup (keeps the runner tidy)
  # ==============================================================
  post-cleanup:
    name: Delete temporary folder (optional)
    needs: [checkout, install-minioclient]
    runs-on: windows-latest
    if: always()
    steps:
      - name: Remove the shared temp directory
        env:
          CLEANUP_DIR: ${{ needs.checkout.outputs.temp-dir }}
        run: |
          if (-not (Test-Path $env:CLEANUP_DIR)) {
            Write-Warning "ðŸŸ¡ Temp directory not found â€“ it may have already been removed."
            exit 0
          }
  
          Write-Host "ðŸ—‘ï¸ Deleting temporary directory: $env:CLEANUP_DIR"
          Remove-Item -Recurse -Force -LiteralPath $env:CLEANUP_DIR
        shell: pwsh
